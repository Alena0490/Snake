<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Snake</title>
</head>
<body>
    <br>
    <br>
    <div class="game">
        <br>
        <div class="score">Score: 0</div>
        <br>
        <canvas id="snake" width="600" height="600"></canvas>
        <script>
		// colors from CSS variables
		const rootStyles = getComputedStyle(document.documentElement);
		const snakeColor = rootStyles.getPropertyValue('--snake-color').trim();
		const snakeTailColor = rootStyles.getPropertyValue('--snake-tail-color').trim();
		const foodColor = rootStyles.getPropertyValue('--food-color-bonus').trim();

		let nextX = 1;  // next direction X
		let nextY = 0;  // next direction Y

		// keyboard listener
		document.addEventListener("keydown", keyPush);

		// canvas setup
		const canvas = document.querySelector("canvas");
		const title = document.querySelector(".score");
		const ctx = canvas.getContext("2d");

		// game state
		let gameIsRunning = true;
		const fps = 2;
		const tileSize = 50;
		const tileCountX = canvas.width / tileSize;
		const tileCountY = canvas.height / tileSize;
		let score = 0;

		// player (snake)
		let snakeSpeed = tileSize;
		let snakePosX = 0;
		let snakePosY = canvas.height / 2;
		let velocityX = 1;
		let velocityY = 0;
		let tail = [];
		let snakeLength = 4;

		// food
		let foodPosX = 0;
		let foodPosY = 0;

		// main loop
		function gameLoop() {
			if (gameIsRunning) {
				drawStuff();
				moveStuff();
				setTimeout(gameLoop, 1000 / fps);
			}
		}

		// initialize tail with snakeLength segments
		tail = [];
		for (let i = snakeLength - 1; i >= 0; i--) {
			tail.push({
				x: snakePosX - i * tileSize,
				y: snakePosY
			});
		}

		resetFood();
		gameLoop();


		/**
		 * MOVE EVERYTHING
		 */
		function moveStuff() {
			// apply new direction at the moment of moving
			velocityX = nextX;
			velocityY = nextY;

			// snake position update
			snakePosX += snakeSpeed * velocityX;
			snakePosY += snakeSpeed * velocityY;

			// wall collision (wrap around)
			if (snakePosX > canvas.width - tileSize) snakePosX = 0;
			if (snakePosX < 0) snakePosX = canvas.width;
			if (snakePosY > canvas.height - tileSize) snakePosY = 0;
			if (snakePosY < 0) snakePosY = canvas.height;

			// self collision -> game over
			tail.forEach((snakePart) => {
				if (snakePosX === snakePart.x && snakePosY === snakePart.y) {
					gameOver();
				}
			});

			// add new head position to tail
			tail.push({ x: snakePosX, y: snakePosY });

			// remove old parts if tail too long
			tail = tail.slice(-1 * snakeLength);

			// food collision
			if (snakePosX === foodPosX && snakePosY === foodPosY) {
				score++;
				title.textContent = `Score: ${score}`;
				snakeLength++;
				resetFood();
			}
		}

		/**
		 * DRAW EVERYTHING
		 */
		function drawStuff() {
			// background
			rectangle("#ffbf00", 0, 0, canvas.width, canvas.height);

			// grid
			drawGrid();

			// food
			rectangle(foodColor, foodPosX, foodPosY, tileSize, tileSize);

			// tail except the last part
			tail.slice(0, -1).forEach((snakePart) =>
				rectangle(snakeColor, snakePart.x, snakePart.y, tileSize, tileSize)
			);

			// head (separate)
			drawHead(snakePosX, snakePosY, tileSize, snakeColor);
		}

		// head = square with rounded corners on the leading side
		function drawHead(x, y, size, color) {
			ctx.fillStyle = color;
			ctx.beginPath();

			const r = size * 0.4; // radius for rounded corners
			const centerX = x + size/2;
			const centerY = y + size/2;

			if (velocityX === 1) { // right
				ctx.moveTo(x, y);
				ctx.lineTo(x + size - r, y);
				ctx.quadraticCurveTo(x + size, y, x + size, y + r);
				ctx.lineTo(x + size, y + size - r);
				ctx.quadraticCurveTo(x + size, y + size, x + size - r, y + size);
				ctx.lineTo(x, y + size);
				ctx.closePath();

			} else if (velocityX === -1) { // left
				ctx.moveTo(x + size, y);
				ctx.lineTo(x + r, y);
				ctx.quadraticCurveTo(x, y, x, y + r);
				ctx.lineTo(x, y + size - r);
				ctx.quadraticCurveTo(x, y + size, x + r, y + size);
				ctx.lineTo(x + size, y + size);
				ctx.closePath();

			} else if (velocityY === -1) { // up
				ctx.moveTo(x, y + size);
				ctx.lineTo(x, y + r);
				ctx.quadraticCurveTo(x, y, x + r, y);
				ctx.lineTo(x + size - r, y);
				ctx.quadraticCurveTo(x + size, y, x + size, y + r);
				ctx.lineTo(x + size, y + size);
				ctx.closePath();

			} else if (velocityY === 1) { // down
				ctx.moveTo(x, y);
				ctx.lineTo(x, y + size - r);
				ctx.quadraticCurveTo(x, y + size, x + r, y + size);
				ctx.lineTo(x + size - r, y + size);
				ctx.quadraticCurveTo(x + size, y + size, x + size, y + size - r);
				ctx.lineTo(x + size, y);
				ctx.closePath();
			}

			ctx.fill();

			// --- eyes ---
			const eyeRadius = size * 0.25;
			const pupilRadius = size * 0.1;
			let eye1X, eye1Y, eye2X, eye2Y;

			if (velocityX === 1) { // right
				eye1X = centerX + size*0.1; eye1Y = centerY - size*0.3;
				eye2X = centerX + size*0.1; eye2Y = centerY + size*0.3;
			} else if (velocityX === -1) { // left
				eye1X = centerX - size*0.1; eye1Y = centerY - size*0.3;
				eye2X = centerX - size*0.1; eye2Y = centerY + size*0.3;
			} else if (velocityY === -1) { // up
				eye1X = centerX - size*0.3; eye1Y = centerY - size*0.1;
				eye2X = centerX + size*0.3; eye2Y = centerY - size*0.1;
			} else if (velocityY === 1) { // down
				eye1X = centerX - size*0.3; eye1Y = centerY + size*0.1;
				eye2X = centerX + size*0.3; eye2Y = centerY + size*0.1;
			}

			// eyes
			ctx.fillStyle = "white";
			ctx.beginPath(); ctx.arc(eye1X, eye1Y, eyeRadius, 0, Math.PI*2); ctx.fill();
			ctx.beginPath(); ctx.arc(eye2X, eye2Y, eyeRadius, 0, Math.PI*2); ctx.fill();

			// pupils
			ctx.fillStyle = "black";
			ctx.beginPath(); ctx.arc(eye1X, eye1Y, pupilRadius, 0, Math.PI*2); ctx.fill();
			ctx.beginPath(); ctx.arc(eye2X, eye2Y, pupilRadius, 0, Math.PI*2); ctx.fill();
		}

		// draw rectangle
		function rectangle(color, x, y, width, height) {
			ctx.fillStyle = color;
			ctx.fillRect(x, y, width, height);
		}

		// randomize food position
		function resetFood() {
			if (snakeLength === tileCountX * tileCountY) {
				gameOver();
			}

			foodPosX = Math.floor(Math.random() * tileCountX) * tileSize;
			foodPosY = Math.floor(Math.random() * tileCountY) * tileSize;

			if (foodPosX === snakePosX && foodPosY === snakePosY) {
				resetFood();
			}

			if (tail.some((snakePart) => snakePart.x === foodPosX && snakePart.y === foodPosY)) {
				resetFood();
			}
		}

		// GAME OVER
		function gameOver() {
			title.innerHTML = `☠️ <strong> ${score} </strong> ☠️`;
			gameIsRunning = false;
		}

		/**
		 * KEYBOARD CONTROLS
		 */
		function keyPush(event) {
			switch (event.key) {
				case "ArrowLeft":
					if (velocityX !== 1) {
						nextX = -1; nextY = 0;
					}
					break;
				case "ArrowUp":
					if (velocityY !== 1) {
						nextX = 0; nextY = -1;
					}
					break;
				case "ArrowRight":
					if (velocityX !== -1) {
						nextX = 1; nextY = 0;
					}
					break;
				case "ArrowDown":
					if (velocityY !== -1) {
						nextX = 0; nextY = 1;
					}
					break;
				default:
					if (!gameIsRunning) location.reload();
					break;
			}
		}

		// draw background grid
		function drawGrid() {
			for (let i = 0; i < tileCountX; i++) {
				for (let j = 0; j < tileCountY; j++) {
					rectangle(
						"#A69185",
						tileSize * i,
						tileSize * j,
						tileSize - 1,
						tileSize - 1
					);
				}
			}
		}
	</script>
</body>
</html>
